"use strict";

function roundTo(number, precision) {
  if ("number" != typeof number) throw new TypeError("Expected value to be a number");
  if (precision === 1 / 0) return number;
  if (!Number.isInteger(precision)) throw new TypeError("Expected precision to be an integer");
  const isNegative = number < 0, inputNumber = isNegative ? Math.abs(number) : number, power = 10 ** precision, result = Math.round(Number((inputNumber * power).toPrecision(15))) / power;
  return isNegative ? -result : result;
}

function capsize(options) {
  if ("leading" in options && "lineGap" in options) throw new Error("Only a single line height style can be provided. Please pass either `lineGap` OR `leading`.");
  if ("capHeight" in options && "fontSize" in options) throw new Error("Please pass either `capHeight` OR `fontSize`, not both.");
  const {fontMetrics: fontMetrics} = options, capHeightScale = fontMetrics.capHeight / fontMetrics.unitsPerEm;
  let specifiedFontSize, specifiedCapHeight, specifiedLineHeight;
  if ("capHeight" in options) specifiedFontSize = options.capHeight / capHeightScale, 
  specifiedCapHeight = options.capHeight; else {
    if (!("fontSize" in options)) throw new Error("Please pass either `capHeight` OR `fontSize`.");
    specifiedFontSize = options.fontSize, specifiedCapHeight = options.fontSize * capHeightScale;
  }
  return "lineGap" in options ? specifiedLineHeight = specifiedCapHeight + options.lineGap : "leading" in options && (specifiedLineHeight = options.leading), 
  createCss({
    lineHeight: specifiedLineHeight,
    fontSize: specifiedFontSize,
    fontMetrics: fontMetrics
  });
}

Object.defineProperty(exports, "__esModule", {
  value: !0
});

const PRECISION = 4;

function createCss({lineHeight: lineHeight, fontSize: fontSize, fontMetrics: fontMetrics}) {
  const absoluteDescent = Math.abs(fontMetrics.descent), capHeightScale = fontMetrics.capHeight / fontMetrics.unitsPerEm, descentScale = absoluteDescent / fontMetrics.unitsPerEm, ascentScale = fontMetrics.ascent / fontMetrics.unitsPerEm, lineGapScale = fontMetrics.lineGap / fontMetrics.unitsPerEm, lineHeightScale = (fontMetrics.ascent + fontMetrics.lineGap + absoluteDescent) / fontMetrics.unitsPerEm, specifiedLineHeightOffset = lineHeight ? (lineHeightScale * fontSize - lineHeight) / 2 : 0, leadingTrim = value => value - (value => value / fontSize)(specifiedLineHeightOffset);
  return {
    fontSize: roundTo(fontSize, 4) + "px",
    lineHeight: lineHeight ? roundTo(lineHeight, 4) + "px" : "normal",
    "::before": {
      content: "''",
      marginBottom: roundTo(-1 * leadingTrim(ascentScale - capHeightScale + lineGapScale / 2), 4) + "em",
      display: "table"
    },
    "::after": {
      content: "''",
      marginTop: roundTo(-1 * leadingTrim(descentScale + lineGapScale / 2), 4) + "em",
      display: "table"
    }
  };
}

const getCapHeight = ({fontSize: fontSize, fontMetrics: fontMetrics}) => roundTo(fontSize * fontMetrics.capHeight / fontMetrics.unitsPerEm, 4);

exports.default = capsize, exports.getCapHeight = getCapHeight;
